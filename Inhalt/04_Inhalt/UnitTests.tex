\chapter{Unit Tests}

\section{10 Unit Tests}

\hyphenation{DirectionTest}
\begin{table}[H]
    \centering
    \begin{tabular}{|p{8cm}|p{8cm}|}
      \hline
      \textbf{Unit Test} & \textbf{Beschreibung} \\
      \hline
      1. VectorTest\#dotTest & Testet \textit{dotTest}-Funktion der Klasse \textit{Vector} darauf, ob sie korrekt Skalarprodukte berechnet \\
      \hline
      2. VectorTest\#lengthTest & Testet \textit{length}-Funktion der Klasse \textit{Vector} darauf, ob sie korrekt Vektorlängen berechnet \\
      \hline
      3. VectorTest\#getClockwiseAngleFromTest & Testet \textit{getClockwiseAngleFrom}-Funktion der Klasse \textit{Vector} darauf, ob sie korrekt Winkel zwischen zwei Vektoren berechnet \\
      \hline
      4. NumericTest\#clampTest & Testet \textit{clamp}-Funktion der Klasse \textit{Numeric} darauf, ob sie korrekt Werte in einem gegebenen Interval einschließt \\
      \hline
      5. EntityTest\#getPreferredMovement DirectionTest & Testet \textit{getPreferredMovementDirection}-Funktion der Klasse \textit{Enemy} darauf, ob sie korrekt eine Bewegung aufgrund der Position des Spielers wählt \\
      \hline
      6. RoomGridTest\#fitsTest & Testet \textit{fits}-Funktion der Klasse \textit{RoomGrid} darauf, ob sie korrekt feststellen kann, ob ein Raum noch auf die Spielkarte passt \\
      \hline
      7. RoomPositionTest\#getMaxDistanceAlongAnyAxisTest & Testet \textit{getMaxDistanceAlongAnyAxis}-Funktion der Klasse \textit{RoomPosition} darauf, ob sie korrekt die maximale Entfernung entlang einer von beiden Axen von einem Punkt zum anderen berechnen kann \\
      \hline
      8. CollectionSelectorTest\#randomSubset Test & Testet \textit{random}-Funktion der Klasse \textit{CollectionSelector} darauf, ob sie korrekt Teilmengen der Auswahl selektiert \\
      \hline
    \end{tabular}
    \caption{Unit Tests mit Beschreibung I}
\end{table}

\begin{table}[H]
    \centering
    \begin{tabular}{|p{8cm}|p{8cm}|}
      \hline
      \textbf{Unit Test} & \textbf{Beschreibung} \\
      \hline
      9. GameStateTest\#movementTest & Testet \textit{dotTest}-Funktion der Klasse \textit{Vector} darauf, ob sie korrekt Skalarprodukte berechnet \\
      \hline
      10. VectorTest\#lengthTest & Testet \textit{length}-Funktion der Klasse \textit{Vector} darauf, ob sie korrekt Vektorlängen berechnet \\
      \hline
    \end{tabular}
    \caption{Unit Tests mit Beschreibung II}
\end{table}

\section{ATRIP: Automatic}
Der Begriff \textit{Automatic} bezieht sich auf die automatische
Ausführung von Unit Tests. Dies kann mit herkömmlichen Test-Frameworks
wie etwa \textit{JUnit5} erreicht werden. 

Dabei können Methoden eigens zum Testen erstellt werden, welche mit
\textit{@Test} annotiert werden. Innerhalb der IDE (z.B. IntelliJ)
können sie dann über einen Befehl oder Knopfdruck einzeln oder im
Gesamten ausgeführt werden.

Die Tests sind so konzipiert, dass sie nicht andere Durchläufe beeinflussen.
Sie sind also unabhängig von einander (\textit{Independence}) und 
wiederholbar (\textit{Repeatability}). Das führt zu nachvollziehbaren
Ergebnissen. Zudem besitzen die Tests keine externen Abhängigkeiten.

Zum Schluss gibt JUnit eine Zusammenfassung aus. Diese beschreibt die
erfolgreichen und fehlgeschlagenen Tests.

\section{ATRIP: Thorough}
\subsection*{Positiv-Beispiel}
Der nachfolgende Code-Ausschnitt zeigt das Positiv-Beispiel zum
\textit{Thorough}-Aspekt. Hierbei wird die
\textit{getClockwiseAngleFromTest()}-Funktion der Klasse
\textit{Vector} getestet, welche den Winkel im Uhrzeigersinn 
zwischen zwei Vektoren berechnet. Dabei gibt es einige verschiedene
Möglichkeiten. Diese hängen unter anderem von der Definitionsreihenfolge
der beiden involvierten Vektoren ab. Dabei beginnt die Winkelmessung
beim zweiten angegebenen Vektor und läuft bis zum ersten Vektor im
Uhrzeigersinn. Es gibt zudem auch Fälle, in denen die Berechnung
fehlschlägt, etwa dann wenn ein Vektor der Nullvektor ist.

Der Test ist \textit{Thorough}, da er als \textit{ParameterizedTest}
umgesetzt ist und die Eingabe-Quelle \textit{getClockwiseAngleFromArguments()}
eine gründliche Stichprobe möglicher Fälle bereitstellt. Dabei werden
etwa Standardfälle in einigen Ausführungen und Definitionsreihenfolgen
ausprobiert, sowie unübliche Fälle, Edge Cases und pathologische Fälle.

\lstset{ 
    language=Java,
    basicstyle=\fontfamily{pcr}\selectfont\footnotesize,
    keywordstyle=\color{purple},
    numberstyle=\tiny,    
    showspaces=false,
    showstringspaces=false,
    showtabs=false, 
    frame=single,
    tabsize=2,
    rulesepcolor=\color{gray},
    rulecolor=\color{black},
    captionpos=b,
    breaklines=true,
    breakatwhitespace=false, 
}

\vspace{1cm}
\begin{lstlisting}[caption={ATRIP: Thorough / Positiv}]
    @ParameterizedTest
    @MethodSource("getClockwiseAngleFromArguments")
    void getClockwiseAngleFromTest(Vector to, Vector from, double angle) {
        assertEquals(angle, to.getClockwiseAngleFrom(from));
    }
    
    private static List<Arguments> getClockwiseAngleFromArguments() {
        return List.of(
                Arguments.of(Vector.UP, Vector.UP, 0D),
                Arguments.of(Vector.RIGHT, Vector.UP, 90D),
                Arguments.of(Vector.UP, Vector.RIGHT, 270D),
                Arguments.of(Vector.LEFT, Vector.UP, 270D),
                Arguments.of(Vector.UP, Vector.LEFT, 90D),
                Arguments.of(Vector.DOWN, Vector.UP, 180D),
                Arguments.of(Vector.UP, Vector.DOWN, 180D),
                
                Arguments.of(new Vector(1, 2), new Vector(1, 2), 0D),
                Arguments.of(new Vector(1, 1), new Vector(1, -1), 90D),
                Arguments.of(new Vector(-1, 1), new Vector(1, -1), 180D),
                
                Arguments.of(new Vector(1, 1), Vector.RIGHT, 45D),
                Arguments.of(new Vector(10000, 0), Vector.UP, 90D),
                
                Arguments.of(new Vector(0, 0), Vector.UP, Double.NEGATIVE_INFINITY),
                Arguments.of(new Vector(0, 0), Vector.RIGHT, Double.NEGATIVE_INFINITY)
        );
    }
\end{lstlisting}

\subsection*{Negativ-Beispiel}

\section{ATRIP: Professional}

\section{Code Coverage}

\section{Fakes und Mocks}